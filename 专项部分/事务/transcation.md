## 事务



### 事务的四大特性

* Atomic  原子性 ： 一组sql命令，要么全部成功，要么一个都没有执行
* Consistency 一致性： 所有的命令同时起效 。
* Isolation 隔离性 ： 事务并发的时候，彼此之间的影响。事务和事务的隔离程度是怎样的。
* Duration 持久性 ： 事务成功后产生的影响能够长久的保持下去。



### 事务并发执行问题

> 正是因为事务并发时产生的这些问题，才产生了事务的隔离级别
>
> ### （1）脏读
>
> #### 1.脏读定义：
>
>   1）说法1：指在一个事务处理过程里读取了另一个未提交的事务中的数据，读取数据不一致。
>   2）说法2：指事务A对数据进行增删改操作，但未提交，另一事务B可以读取到未提交的数据。如果事务A这时候回滚了，则第二个事务B读取的即为脏数据。
>
> #### 2.举例：
>
>   当一个事务正在多次修改某个数据，而在这个事务中多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。
>  例如：用户A向用户B转账100元，对应SQL命令如下
>  　update account set money=money+100 where name=’B’;  (此时A通知B)
>  　update account set money=money - 100 where name=’A’;
>  当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。
>
> ### （2）不可重复读： 读取的时候要否要对整个行加锁
>
> #### 1.不可重复读定义：
>
>   1）说法1：是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
>   2）说法2：一个事务A中发生了两次读操作，第一次读操作和第二次读操作之间，另一个事务B对数据进行了修改，这时两个事务读取的数据不一致。
>
> #### 2.举例：
>
>   例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。
>
> #### 3.不可重复读和脏读的区别：
>
>   脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。
>   在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……
>
> ### （3）虚读(幻读)
>
> #### 1.幻读定义：
>
>   1）说法1：是事务非独立执行时发生的一种现象。
>   2）说法2：第一个事务A对一定范围的数据进行批量修改，第二个事务B在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。
>
> #### 2.举例：
>
>   例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
>
> #### 3.幻读和不可重复读区别：
>
>   都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。



### 事务的传播特性

* 当两个事务处于嵌套的情况的时候，应该如何处理的这种情况？



1. **PROPAGATION_REQUIRED。 最合理的方式**

+ 如果当前已经存在事务，那么加入该事务，如果不存在事务

  是一种最合理的方式；

2. **PROPAGATION_REQUIRES_NEW。 有洁癖的事务**

* 无论父事务是否有事务，都要重新创建一个事务

3. **PROPAGATION_SUPPORTS。 加了和没加一样**

* 这个是相当于没有没有加事务

5. **PROPAGETEION_MANDATORY。不适应穷苦家庭的事务，不然不能生存**

   使用这种模式要求父方法必须有事务，不然会抛出异常。

   支持当前事务，A如果有事务，B将使用该事务。 如果A没有事务，B将抛异常。

6. **PROPAGATION_NOT_SUPPORTED 讨厌事务，不要事务** 

* 必须以没有事务的方式进行，父方法有事务，则将父事务进行挂起。

7. **PROPAGATION_NEVER 很坏的人，自己不用事务，别人也同样不能用事务，不然举报**

* 如果当前存在事务，则抛出异常，否则在无事务环境上执行代码。

8. **PROPAGATION_NESTED 共用一个事务，不过在方法交界处设置一个savePoint**

* 如果当前存在事务，则使用 SavePoint 技术把当前事务状态进行保存，然后底层共用一个连接，当NESTED内部出错的时候，自行回滚到 SavePoint这个状态，只要外部捕获到了异常，就可以继续进行外部的事务提交，而不会受到内嵌业务的干扰，但是，如果外部事务抛出了异常，整个大事务都会回滚
  







