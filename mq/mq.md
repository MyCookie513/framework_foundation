## MQ 消息队列

* 背景

  > 当我们数据库中的信息改变了后，我们要同步更新 索引库中的信息，以及其他的相关微服务中进行的操作，当然我们可以之间调用其他微服务的接口，但是这就造成代码的严重耦合。
  >
  > 所以我们就可以利用消息队列这种工具服务来解藕这种关系，同时实现连锁反应的功能。 

* 定义

    消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。



### 一 . Advanced Message Queue Protocol AMQP 高级消息队列协议

* 是为面向消息的中间件设定的一种协议。统一消息传递的标准；不受开发语言的限制。



### 二 . java message service  JMS

![](images/jms.png)





### 两种实现消息队列方式对比

- JMS是**定义了统一的接口**，来对消息操作进行统一，**并没有统一交互规则**；AMQP是通过规定协议来统一数据交互的格式
- JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。
- JMS规定了两种消息模型；而AMQP的消息模型更加丰富







### 常见的MQ产品

* RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好
* RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会
* Kafka：分布式消息系统，高吞吐量





### 基本消息模型

* 直接绑定队列

  + 生产者直接绑定队列
  + 多个消费者也是直接绑定队列
  + 应该选择能者多劳，而不是公平分配。

  ![](images/oneToMany.png)

* 订阅模式

  + Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：

    + Fanout：广播，将消息交给所有绑定到交换机的队列

      + 生产者直接向某个交换机中发送消息即可
      + 每个队列都可以接收到消息

      ![](images/Fanout.png)

    

    

    + Direct：定向，把消息交给符合指定routing key 的队列

      + 以队列为单位，每种队列订阅了不同的频道
      + 生产者向exchange发送消息之前，要说明发送消息的频道

      ![](images/Direct.png)

    

    

    + Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列，只是比Direct模式多了通配符的使用。

      + 队列在绑定`Routing key` 的时候使用通配符
      + 生产者和消费者方式和direct模式一样。

      ![](images/topic.png)

  







### 消费者的消息确认机制(Acknowlage)

- 自动ACK：消息一旦被接收，消费者自动发送ACK
- 手动ACK：消息接收后，不会发送ACK，需要手动调用

##### 如果消息非常重要，不容丢失。

* 那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了



### 避免消息丢失进行持久化

* exchange 交换机
* message 消息
* queue 队列





